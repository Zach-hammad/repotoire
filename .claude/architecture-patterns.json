{
  "multi-tenant-isolation": {
    "description": "Two-layer defense-in-depth isolation: graph-level (physical) + node-level (logical)",
    "implemented_via": [
      "GraphClientFactory - separate FalkorDB graph per organization (Layer 1)",
      "TenantMiddleware - sets TenantContext from ClerkUser",
      "TenantContext - async-safe ContextVar propagation",
      "QueryBuilder.with_tenant() - automatic tenant filtering in Cypher",
      "BaseDetector._get_isolation_filter() - combined tenant_id + repo_id filtering (Layer 2)",
      "GraphAlgorithms._get_isolation_filter() - tenant filtering in graph algorithms",
      "TimescaleClient - tenant_id column in all metrics tables",
      "MCP server - REPOTOIRE_ORG_ID env var for tenant context"
    ],
    "key_files": [
      "repotoire/graph/tenant_factory.py",
      "repotoire/api/shared/middleware/tenant.py",
      "repotoire/tenant/context.py",
      "repotoire/graph/queries/builders.py",
      "repotoire/detectors/base.py",
      "repotoire/detectors/graph_algorithms.py",
      "repotoire/historical/timescale_client.py",
      "mcp_server/repotoire_mcp_server.py"
    ],
    "property_names": ["tenant_id", "tenantId", "org_id", "repo_id", "repoId"],
    "patterns": ["graph-level-isolation", "middleware-context", "factory-pattern", "contextvar-propagation", "defense-in-depth"],
    "notes": "Primary isolation is at graph level (each org has separate FalkorDB graph). Node-level tenantId/repoId is defense-in-depth. Use _get_isolation_filter() NOT _get_repo_filter() for all detectors."
  },
  "authentication": {
    "description": "Clerk-based authentication with JWT and API key support",
    "implemented_via": [
      "ClerkMiddleware - JWT validation",
      "get_current_user_or_api_key - flexible auth dependency",
      "enforce_feature_for_api - feature gating + org lookup"
    ],
    "key_files": [
      "repotoire/api/shared/auth/clerk.py",
      "repotoire/api/shared/middleware/usage.py"
    ],
    "patterns": ["middleware-stack", "dependency-injection", "api-key-auth"]
  },
  "input-validation": {
    "description": "Pydantic models + FastAPI automatic validation",
    "implemented_via": [
      "Pydantic BaseModel schemas",
      "FastAPI automatic request validation",
      "Path/Query parameter validation"
    ],
    "key_files": [
      "repotoire/api/schemas/",
      "repotoire/models.py"
    ],
    "patterns": ["pydantic-validation", "fastapi-automatic"]
  },
  "vector-search": {
    "description": "Hybrid vector + graph search with multiple backends",
    "implemented_via": [
      "GraphRAGRetriever - hybrid search orchestration",
      "VectorStore abstraction - LanceDB/graph backends",
      "CodeEmbedder - OpenAI/DeepInfra/local backends"
    ],
    "key_files": [
      "repotoire/ai/retrieval.py",
      "repotoire/ai/vector_store.py",
      "repotoire/ai/embeddings.py"
    ],
    "property_names": ["embedding", "vector", "similarity_score"],
    "patterns": ["abstract-factory", "strategy-pattern", "hybrid-search"]
  },
  "git-history-queries": {
    "description": "Natural language queries over git commit history using RAG",
    "implemented_via": [
      "GitHistoryRAG - vector + BM25 hybrid search over commits",
      "CommitEntity nodes in FalkorDB with embeddings",
      "Claude Haiku for answer generation",
      "NLQ API endpoints: /nlq, /nlq/search, /nlq/status/{repository_id}",
      "CLI commands: repotoire historical ask/search/ingest/status"
    ],
    "key_files": [
      "repotoire/historical/git_rag.py",
      "repotoire/cli/historical.py",
      "repotoire/historical/git_extractor.py",
      "repotoire/api/v1/routes/historical.py"
    ],
    "patterns": ["rag-retrieval", "hybrid-search", "local-embeddings"],
    "notes": "Graphiti was REMOVED in Jan 2026 - too expensive ($10-20/1000 commits vs FREE). GitHistoryRAG uses local embeddings for FREE ingestion + $0.001/query with Claude Haiku. All Graphiti code, tests, and dependencies were deleted.",
    "removed_in_cleanup": {
      "date": "2026-01-27",
      "reason": "Cost prohibitive - Graphiti required LLM calls per commit ($10-20/1000 commits)",
      "files_deleted": [
        "repotoire/historical/git_graphiti.py",
        "tests/unit/test_git_graphiti.py",
        "tests/integration/test_mcp_git_graphiti.py",
        "tests/integration/test_historical_routes.py",
        "repotoire/web/tests/e2e/historical-api.spec.ts"
      ],
      "dependencies_removed": ["graphiti-core", "neo4j", "posthog"],
      "endpoints_removed": ["/ingest-git", "/ingest-commits", "/query", "/timeline", "/issue-origin", "/status/{repo_id}", "/commits", "/backfill", "/correct"]
    }
  },
  "timescale-metrics": {
    "description": "Historical code health metrics tracking with TimescaleDB",
    "implemented_via": [
      "TimescaleClient - connection and query management",
      "MetricsCollector - extract metrics from CodebaseHealth",
      "Hypertables with tenant_id partitioning"
    ],
    "key_files": [
      "repotoire/historical/timescale_client.py",
      "repotoire/historical/metrics_collector.py",
      "repotoire/historical/schema.sql"
    ],
    "property_names": ["tenant_id", "repository", "branch"],
    "patterns": ["time-series", "tenant-isolation", "continuous-aggregates"],
    "notes": "All TimescaleDB queries MUST include tenant_id filter. Primary key is (time, tenant_id, repository, branch)."
  }
}
