{
  "multi-tenant-isolation": {
    "description": "Two-layer defense-in-depth isolation: graph-level (physical) + node-level (logical)",
    "implemented_via": [
      "GraphClientFactory - separate FalkorDB graph per organization (Layer 1)",
      "TenantMiddleware - sets TenantContext from ClerkUser",
      "TenantContext - async-safe ContextVar propagation",
      "QueryBuilder.with_tenant() - automatic tenant filtering in Cypher",
      "BaseDetector._get_isolation_filter() - combined tenant_id + repo_id filtering (Layer 2)",
      "GraphAlgorithms._get_isolation_filter() - tenant filtering in graph algorithms",
      "TimescaleClient - tenant_id column in all metrics tables",
      "MCP server - REPOTOIRE_ORG_ID env var for tenant context"
    ],
    "key_files": [
      "repotoire/graph/tenant_factory.py",
      "repotoire/api/shared/middleware/tenant.py",
      "repotoire/tenant/context.py",
      "repotoire/graph/queries/builders.py",
      "repotoire/detectors/base.py",
      "repotoire/detectors/graph_algorithms.py",
      "repotoire/historical/timescale_client.py",
      "mcp_server/repotoire_mcp_server.py"
    ],
    "property_names": ["tenant_id", "tenantId", "org_id", "repo_id", "repoId"],
    "patterns": ["graph-level-isolation", "middleware-context", "factory-pattern", "contextvar-propagation", "defense-in-depth"],
    "notes": "Primary isolation is at graph level (each org has separate FalkorDB graph). Node-level tenantId/repoId is defense-in-depth. Use _get_isolation_filter() NOT _get_repo_filter() for all detectors."
  },
  "authentication": {
    "description": "Clerk-based authentication with JWT and API key support",
    "implemented_via": [
      "ClerkMiddleware - JWT validation",
      "get_current_user_or_api_key - flexible auth dependency",
      "enforce_feature_for_api - feature gating + org lookup"
    ],
    "key_files": [
      "repotoire/api/shared/auth/clerk.py",
      "repotoire/api/shared/middleware/usage.py"
    ],
    "patterns": ["middleware-stack", "dependency-injection", "api-key-auth"]
  },
  "input-validation": {
    "description": "Pydantic models + FastAPI automatic validation",
    "implemented_via": [
      "Pydantic BaseModel schemas",
      "FastAPI automatic request validation",
      "Path/Query parameter validation"
    ],
    "key_files": [
      "repotoire/api/schemas/",
      "repotoire/models.py"
    ],
    "patterns": ["pydantic-validation", "fastapi-automatic"]
  },
  "vector-search": {
    "description": "Hybrid vector + graph search with multiple backends",
    "implemented_via": [
      "GraphRAGRetriever - hybrid search orchestration",
      "VectorStore abstraction - LanceDB/graph backends",
      "CodeEmbedder - OpenAI/DeepInfra/local backends"
    ],
    "key_files": [
      "repotoire/ai/retrieval.py",
      "repotoire/ai/vector_store.py",
      "repotoire/ai/embeddings.py"
    ],
    "property_names": ["embedding", "vector", "similarity_score"],
    "patterns": ["abstract-factory", "strategy-pattern", "hybrid-search"]
  },
  "git-history-queries": {
    "description": "Natural language queries over git commit history using RAG",
    "implemented_via": [
      "GitHistoryRAG - vector + BM25 hybrid search over commits",
      "CommitEntity nodes in FalkorDB with embeddings",
      "Claude Haiku for answer generation",
      "NLQ API endpoints: /nlq, /nlq/search, /nlq/status/{repository_id}",
      "CLI commands: repotoire historical ask/search/ingest/status"
    ],
    "key_files": [
      "repotoire/historical/git_rag.py",
      "repotoire/cli/historical.py",
      "repotoire/historical/git_extractor.py",
      "repotoire/api/v1/routes/historical.py"
    ],
    "patterns": ["rag-retrieval", "hybrid-search", "local-embeddings"],
    "notes": "Graphiti was REMOVED in Jan 2026 - too expensive ($10-20/1000 commits vs FREE). GitHistoryRAG uses local embeddings for FREE ingestion + $0.001/query with Claude Haiku. All Graphiti code, tests, and dependencies were deleted.",
    "removed_in_cleanup": {
      "date": "2026-01-27",
      "reason": "Cost prohibitive - Graphiti required LLM calls per commit ($10-20/1000 commits)",
      "files_deleted": [
        "repotoire/historical/git_graphiti.py",
        "tests/unit/test_git_graphiti.py",
        "tests/integration/test_mcp_git_graphiti.py",
        "tests/integration/test_historical_routes.py",
        "repotoire/web/tests/e2e/historical-api.spec.ts"
      ],
      "dependencies_removed": ["graphiti-core", "neo4j", "posthog"],
      "endpoints_removed": ["/ingest-git", "/ingest-commits", "/query", "/timeline", "/issue-origin", "/status/{repo_id}", "/commits", "/backfill", "/correct"]
    }
  },
  "timescale-metrics": {
    "description": "Historical code health metrics tracking with TimescaleDB",
    "implemented_via": [
      "TimescaleClient - connection and query management",
      "MetricsCollector - extract metrics from CodebaseHealth",
      "Hypertables with tenant_id partitioning"
    ],
    "key_files": [
      "repotoire/historical/timescale_client.py",
      "repotoire/historical/metrics_collector.py",
      "repotoire/historical/schema.sql"
    ],
    "property_names": ["tenant_id", "repository", "branch"],
    "patterns": ["time-series", "tenant-isolation", "continuous-aggregates"],
    "notes": "All TimescaleDB queries MUST include tenant_id filter. Primary key is (time, tenant_id, repository, branch). All queries use %s parameterized placeholders - NO SQL injection vulnerabilities."
  },
  "rate-limiting": {
    "description": "Tiered rate limiting with Redis backend and standard headers",
    "implemented_via": [
      "slowapi.Limiter - core rate limiting engine with Redis/memory storage",
      "RateLimitMiddleware - adds X-RateLimit-* headers to all responses",
      "RateLimitTier enum - FREE (60/min), PRO (300/min), ENTERPRISE (1000/min)",
      "Category-based limits - api, analysis, webhook, sensitive, api_key_validation, account, search",
      "rate_limit_exceeded_handler - 429 responses with Retry-After header"
    ],
    "key_files": [
      "repotoire/api/shared/middleware/rate_limit.py",
      "repotoire/api/app.py"
    ],
    "patterns": ["middleware-stack", "redis-backend", "tiered-limits"],
    "notes": "Rate limiting is FULLY IMPLEMENTED. Check app.py:399 for middleware registration, app.py:101-104 for Limiter init. Headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, Retry-After."
  },
  "security-headers": {
    "description": "Comprehensive security headers via middleware",
    "implemented_via": [
      "SecurityHeadersMiddleware - adds all security headers",
      "X-Content-Type-Options: nosniff",
      "X-Frame-Options: DENY",
      "X-XSS-Protection: 1; mode=block",
      "Strict-Transport-Security (HSTS) - production only",
      "Content-Security-Policy (CSP) - restrictive default-src 'none'",
      "Permissions-Policy - disables camera, microphone, geolocation, etc.",
      "Referrer-Policy: strict-origin-when-cross-origin",
      "Cache-Control: no-store for API responses"
    ],
    "key_files": [
      "repotoire/api/shared/middleware/security_headers.py",
      "repotoire/api/app.py"
    ],
    "patterns": ["middleware-stack", "defense-in-depth"],
    "notes": "Security headers middleware registered at app.py:408. HSTS only in production (ENVIRONMENT=production). CSP_REPORT_URI env var supported for violation reports."
  },
  "cors-configuration": {
    "description": "Explicit CORS origins - NOT wildcards",
    "implemented_via": [
      "CORSMiddleware from Starlette",
      "CORS_ORIGINS env var - comma-separated list",
      "Explicit allow_methods - GET, POST, PUT, DELETE, PATCH, OPTIONS",
      "Explicit allow_headers - Authorization, Content-Type, X-API-Key, X-Request-ID"
    ],
    "key_files": [
      "repotoire/api/app.py"
    ],
    "patterns": ["explicit-allowlist", "no-wildcards"],
    "notes": "CORS does NOT use wildcards. Default origins: http://localhost:3000,http://localhost:3001. See app.py:93-96 for CORS_ORIGINS, app.py:413-419 for middleware config."
  },
  "webhook-security": {
    "description": "HMAC signature verification for all webhooks",
    "implemented_via": [
      "github.verify_webhook_signature() - HMAC-SHA256 verification",
      "Svix for Clerk webhook verification",
      "Stripe webhook signature verification",
      "401 Unauthorized for invalid signatures"
    ],
    "key_files": [
      "repotoire/api/shared/services/github.py",
      "repotoire/api/v1/routes/github.py",
      "repotoire/api/v1/routes/webhooks.py",
      "repotoire/api/v1/routes/customer_webhooks.py"
    ],
    "patterns": ["hmac-verification", "constant-time-comparison"],
    "notes": "GitHub webhook verification at github.py route line 457: if not github.verify_webhook_signature(body, signature). Uses hmac.compare_digest for timing-safe comparison."
  },
  "api-key-validation": {
    "description": "Secure API key validation via Clerk SDK",
    "implemented_via": [
      "clerk.api_keys.verify_api_key() - Clerk SDK method",
      "No direct string comparison - SDK handles timing-safe validation",
      "Rate limited: 10/minute for validation endpoint",
      "Scoped keys with org-level permissions"
    ],
    "key_files": [
      "repotoire/api/shared/auth/clerk.py",
      "repotoire/api/v1/routes/cli_auth.py"
    ],
    "patterns": ["sdk-delegation", "timing-safe"],
    "notes": "API key validation uses Clerk SDK, NOT custom string comparison. See clerk.py:234 for verify_api_key call. No timing attack vulnerability."
  },
  "sql-injection-prevention": {
    "description": "All SQL queries use parameterized placeholders",
    "implemented_via": [
      "psycopg2 %s placeholders for all TimescaleDB queries",
      "SQLAlchemy ORM for PostgreSQL queries",
      "No f-string interpolation of user input in SQL"
    ],
    "key_files": [
      "repotoire/historical/timescale_client.py",
      "repotoire/db/"
    ],
    "patterns": ["parameterized-queries", "orm"],
    "notes": "TimescaleClient uses cur.execute('...WHERE x = %s...', (param,)) pattern throughout. No SQL injection vulnerabilities."
  },
  "command-injection-prevention": {
    "description": "All subprocess calls use list arguments, not shell=True",
    "implemented_via": [
      "run_external_tool() - shared utility for all external tools",
      "subprocess.run(cmd_list, ...) - list argument, shell=False default",
      "No shell interpretation of user input"
    ],
    "key_files": [
      "repotoire/detectors/external_tool_runner.py",
      "repotoire/cli/repo_utils.py"
    ],
    "patterns": ["subprocess-list", "no-shell"],
    "notes": "All subprocess calls use list for cmd argument. shell=False is default. See external_tool_runner.py:232 for subprocess.run pattern."
  },
  "sandbox-secret-filtering": {
    "description": "E2B sandbox excludes sensitive files before upload",
    "implemented_via": [
      "DEFAULT_SENSITIVE_PATTERNS - 50+ file patterns (.env, credentials, keys, etc.)",
      "SECRET_CONTENT_PATTERNS - regex patterns for API keys in file contents",
      "SecretFileFilter class - pattern + content scanning",
      "SANDBOX_EXCLUDE_PATTERNS env var for custom patterns"
    ],
    "key_files": [
      "repotoire/sandbox/tool_executor.py"
    ],
    "patterns": ["pattern-matching", "content-scanning", "defense-in-depth"],
    "notes": "E2B sandbox filters: .env*, .aws/, .ssh/, credentials.json, *.pem, *password*, etc. Also scans file CONTENTS for API key patterns (AKIA*, ghp_*, sk_live_*, etc.)."
  },
  "csrf-protection": {
    "description": "CSRF protection via Origin header validation",
    "implemented_via": [
      "CSRFProtectionMiddleware - validates Origin on state-changing requests",
      "Registered in middleware stack before route handlers"
    ],
    "key_files": [
      "repotoire/api/shared/middleware/csrf.py",
      "repotoire/api/app.py"
    ],
    "patterns": ["origin-validation", "middleware"],
    "notes": "CSRF middleware registered at app.py:396. Validates Origin header matches allowed origins for POST/PUT/DELETE requests."
  },
  "idempotency-keys": {
    "description": "Safe request retries via Idempotency-Key header for POST/PUT/PATCH",
    "implemented_via": [
      "IdempotencyMiddleware - caches responses by Idempotency-Key header",
      "IdempotencyStore - TTL-based cache with LRU eviction (24h default, 10k max)",
      "User/org isolation - cache keys scoped per user_id or org_id",
      "X-Idempotency-Replayed header on cache hits"
    ],
    "key_files": [
      "repotoire/api/shared/middleware/idempotency.py",
      "repotoire/api/app.py"
    ],
    "patterns": ["middleware-stack", "cache-aside", "user-isolation"],
    "notes": "Idempotency middleware registered at app.py:395. Only caches 2xx responses. Max key length 64 chars. CORS allows Idempotency-Key header."
  },
  "cursor-pagination": {
    "description": "Cursor-based pagination for search endpoints",
    "implemented_via": [
      "CodeSearchRequest.cursor - opaque pagination cursor input",
      "CodeSearchResponse.next_cursor, has_more - pagination state output",
      "_encode_cursor/_decode_cursor - base64 JSON encoding",
      "Fetch N+1 results to determine has_more without COUNT query"
    ],
    "key_files": [
      "repotoire/api/models.py",
      "repotoire/api/v1/routes/code.py"
    ],
    "patterns": ["cursor-pagination", "opaque-cursor", "fetch-plus-one"],
    "notes": "Cursor format is base64-encoded JSON with offset. Max cursor length 100 chars. Decoding errors return offset 0 (graceful fallback)."
  },
  "async-blocking-prevention": {
    "description": "Prevent event loop blocking with asyncio.to_thread for sync operations",
    "implemented_via": [
      "asyncio.to_thread() wrapper for sync retriever.retrieve() calls",
      "Allows concurrent request handling during I/O operations",
      "Applied to GraphRAGRetriever which uses sync FalkorDB driver"
    ],
    "key_files": [
      "repotoire/api/v1/routes/code.py"
    ],
    "patterns": ["thread-pool-offload", "async-sync-bridge"],
    "notes": "Any sync I/O in async endpoints MUST use asyncio.to_thread(). The FalkorDB driver is synchronous, so all retriever calls are wrapped."
  },
  "response-caching": {
    "description": "Query result caching via RAGCache",
    "implemented_via": [
      "RAGCache - LRU cache for retrieval results",
      "Cache key includes query, top_k, entity_types, include_related",
      "TTL-based expiration"
    ],
    "key_files": [
      "repotoire/ai/retrieval.py"
    ],
    "patterns": ["lru-cache", "query-caching"],
    "notes": "RAGCache handles query-level caching. HTTP caching headers (Cache-Control, ETag) not yet implemented."
  },
  "pydantic-validation": {
    "description": "Request/response validation via Pydantic models with Field constraints",
    "implemented_via": [
      "Pydantic BaseModel with Field() validators",
      "ge/le for numeric bounds (e.g., top_k: ge=1, le=50)",
      "min_length/max_length for strings",
      "FastAPI automatic 422 responses for validation errors"
    ],
    "key_files": [
      "repotoire/api/models.py",
      "repotoire/api/schemas/"
    ],
    "patterns": ["declarative-validation", "automatic-422"],
    "notes": "Input validation is AUTOMATIC via Pydantic. Check models.py for Field() constraints. No manual validation needed in route handlers."
  }
}
